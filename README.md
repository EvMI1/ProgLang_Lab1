# Фадеев Михаил БАС-1 Лабораторная №1
# Задание 1

## Задача 1

### Текст задачи

Сформировать список из чисел, обратных вводимым значениям.

### Алгоритм решения

Описана функция разворота числа `Reverse` (композиция функция). Значение `sign` запоминает знак числа, внутренняя рекурсивная функция `loop` выполняет разворот, принимая 2 параметра: остаток от числа `num` и уже накопившийся результат `acc`, берет последнюю цифру и дописывает в результат. Функция `generate_list` принимает размер списка (с предварительной проверкой этого числа на корректность ввода), запрашивает числа и генерирует из результата работы функции `Reverse` список.  

### Тестирование

![Pasted image 20260223161147.png](https://github.com/EvMI1/ProgLang_Lab1/blob/main/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/Pasted%20image%2020260223161147.png)

![Pasted image 20260223161319.png](https://github.com/EvMI1/ProgLang_Lab1/blob/main/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/Pasted%20image%2020260223161319.png)

![Pasted image 20260223161544.png](https://github.com/EvMI1/ProgLang_Lab1/blob/main/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/Pasted%20image%2020260223161544.png)

# Задание 2
## Задача 1

### Текст задачи

Найти количество цифр в записи натурального числа.

### Алгоритм решения

Получаем от пользователя число и проверяем корректность ввода на принадлежность числа к множеству натуральных чисел. Вызов рекурсивной функции `count_even`. Пока число не равно нулю, выполняется следующее: берётся последняя цифру числа, взяв остаток от деления на 10. Проверка, является ли она чётной. Если да — увеличиваем счётчик на единицу. После этого отбрасываем последнюю цифру, разделив число нацело на 10.

### Тестирование
![Pasted image 20260223163504.png](https://github.com/EvMI1/ProgLang_Lab1/blob/main/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/Pasted%20image%2020260223163504.png)

![Pasted image 20260223163531.png](https://github.com/EvMI1/ProgLang_Lab1/blob/main/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/Pasted%20image%2020260223163531.png)

![Pasted image 20260223163617.png](https://github.com/EvMI1/ProgLang_Lab1/blob/main/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/Pasted%20image%2020260223163617.png)

![Pasted image 20260223163643.png](https://github.com/EvMI1/ProgLang_Lab1/blob/main/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/Pasted%20image%2020260223163643.png)



# Задание 3

## Задача 1

### Текст задачи

Опишите функции, осуществляющие основные математические операции над комплексными числами (сложение, вычитание, умножение, деление, возведение в степень). Использовать готовый класс Complex запрещено.

### Алгоритм решения

Описан тип `complex_numb` — запись с двумя полями `real` и `im` типа `float`, представляющая комплексное число в алгебраической форме a + bi.

Функция `InputComplex` запрашивает у пользователя действительную и мнимую части, считывает их из консоли, преобразует в `float` и возвращает запись типа `complex_numb`.

Функция `PrintComplex` принимает комплексное число и выводит его в читаемом виде: проверяет знак мнимой части для корректного форматирования (используя `abs` для отрицательных значений), обрабатывает особые случаи когда одна из частей равна нулю.

Функции `add` и `sub` реализуют сложение и вычитание комплексных чисел по правилу покомпонентной операции: для сложения складываются действительные и мнимые части отдельно, для вычитания — вычитаются.

Функция `multiply` реализует умножение комплексных чисел по формуле (a+bi)(c+di) = (ac-bd) + (ad+bc)i, раскрывая скобки с учётом того, что i² = -1.

Функция `divide` реализует деление через умножение числителя и знаменателя на комплексно сопряжённое знаменателя. Вычисляет знаменатель `denom = c² + d²`, проверяет его на ноль (при делении на ноль выводит сообщение об ошибке и возвращает нулевое комплексное число), иначе возвращает результат по формуле.

Рекурсивная функция `pow` реализует возведение в целую неотрицательную степень методом быстрого возведения в степень (exponentiation by squaring). Базовые случаи: если степень отрицательная — выводит ошибку и возвращает ноль, если степень равна 0 — возвращает 1, если 1 — возвращает само число. Рекурсивный случай: вычисляет `p = pow c (n/2)` — число в половинной степени, затем `p2 = multiply p p` — квадрат этого результата. Если степень чётная — возвращает `p2`, если нечётная — домножает на исходное число `multiply c p2`. Это даёт логарифмическую сложность O(log n) вместо линейной.

### Тестирование
![Pasted image 20260223165636.png](https://github.com/EvMI1/ProgLang_Lab1/blob/main/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/Pasted%20image%2020260223165636.png)

![Pasted image 20260223165706.png](https://github.com/EvMI1/ProgLang_Lab1/blob/main/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/Pasted%20image%2020260223165706.png)

![Pasted image 20260223165747.png](https://github.com/EvMI1/ProgLang_Lab1/blob/main/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/Pasted%20image%2020260223165747.png)

![Pasted image 20260223165847.png](https://github.com/EvMI1/ProgLang_Lab1/blob/main/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/Pasted%20image%2020260223165847.png)

![Pasted image 20260223165921.png](https://github.com/EvMI1/ProgLang_Lab1/blob/main/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/Pasted%20image%2020260223165921.png)

![Pasted image 20260223170100.png](https://github.com/EvMI1/ProgLang_Lab1/blob/main/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/Pasted%20image%2020260223170100.png)

![Pasted image 20260223170217.png](https://github.com/EvMI1/ProgLang_Lab1/blob/main/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/Pasted%20image%2020260223170217.png)

